# Top Down Operator Precedence JavaScript Parser

  In Douglas Crockford's article [Top Down Operator Precedence](http://javascript.crockford.com/tdop/tdop.html) [1]
he implements a parser first presented by Vaughan Pratt. I'll be building the same Parser myself, with the hopes of extending it for fun.  
<br>

# Simplified JavaScript
  Crockfords original parser was designed for parsing *Simplified JavaScript*, or "just the good stuff" [1]. In his own words, it includes:

* Functions as first class objects. Functions in Simplified JavaScript are lambdas with lexical scoping.

* Dynamic objects with prototypal inheritance. Objects are class-free. We can add a new member to any object by ordinary assignment. An object can inherit members from another object.

* Object literals and array literals. This is a very convenient notation for creating new objects and arrays. JavaScript literals were the inspiration for the JSON data interchange format[1].

<br>
# TDOP Basics

  Top Down Operator Precedence (TDOP) is a type of
        parser that is based on a Recursive descent model,
        but it differs by treating the tokens as something
        simmilar to objects. Recursive descent associates
        'semantic actions' with grammer rules, while TDOP
        has the actions associated with the tokens [2].

  This feature allows for TDOP to be implemented
        very well by a dynamic functional-object-oriented
        language like JavaScript. Generic objects first
        created by a factory function, and methods can then
        be dynamically assigned to allow for the token to
        handle its own parsing logic.



<br>
# Background






# Use

  As this project is in a very early stage, it has limited useability. 
It currently runs on NodeJS, but I hope to extend it for the browser too. 
The `printTree` module will take a JS file as an argument, and output the tree 
generated by `parser.js` to the command-line. 
<br>
<br>
A few *Simplified JavaScript* test files are included; for instance, `test03.js` looks like:

##test03.js
```javascript

var beans = function cool (x, y, z) {
  return x + y * z;
};
```
<br>
<br>
You can see how the parser works by using `printTree` on the `test03.js` file (or any *Simplified JavaScript*) via

```
$ node printTree test03.js
```
<br>
<br>
The output should look like so:
```
Scanning..
Parsing..
Printing Tree for test03.js:

{ value: '=',
  arity: 'binary',
  first: 
   { value: 'beans',
     arity: 'name',
     reserved: false,
     nud: [Function: itself],
     led: null,
     std: null,
     lbp: 0,
     scope: 
      { def: 
         { var: { value: 'var', arity: 'name', reserved: true },
           beans: [Circular] },
        parent: undefined } },
  second: 
   { value: 'function',
     arity: 'function',
     name: 'cool',
     first: 
      [ { value: 'x',
          arity: 'name',
          reserved: false,
          nud: [Function: itself],
          led: null,
          std: null,
          lbp: 0,
          scope: 
           { def: 
              { cool: 
                 { value: 'cool',
                   arity: 'name',
                   reserved: false,
                   nud: [Function: itself],
                   led: null,
                   std: null,
                   lbp: 0,
                   scope: [Circular] },
                x: [Circular],
                y: 
                 { value: 'y',
                   arity: 'name',
                   reserved: false,
                   nud: [Function: itself],
                   led: null,
                   std: null,
                   lbp: 0,
                   scope: [Circular] },
                z: 
                 { value: 'z',
                   arity: 'name',
                   reserved: false,
                   nud: [Function: itself],
                   led: null,
                   std: null,
                   lbp: 0,
                   scope: [Circular] },
                return: 
                 { value: 'return',
                   arity: 'statement',
                   reserved: true,
                   first: 
                    { value: '+',
                      arity: 'binary',
                      first: { value: 'x', arity: 'name' },
                      second: 
                       { value: '*',
                         arity: 'binary',
                         first: { value: 'y', arity: 'name' },
                         second: { value: 'z', arity: 'name' } } } } },
             parent: 
              { def: 
                 { var: { value: 'var', arity: 'name', reserved: true },
                   beans: 
                    { value: 'beans',
                      arity: 'name',
                      reserved: false,
                      nud: [Function: itself],
                      led: null,
                      std: null,
                      lbp: 0,
                      scope: [Circular] } },
                parent: undefined } } },
        { value: 'y',
          arity: 'name',
          reserved: false,
          nud: [Function: itself],
          led: null,
          std: null,
          lbp: 0,
          scope: 
           { def: 
              { cool: 
                 { value: 'cool',
                   arity: 'name',
                   reserved: false,
                   nud: [Function: itself],
                   led: null,
                   std: null,
                   lbp: 0,
                   scope: [Circular] },
                x: 
                 { value: 'x',
                   arity: 'name',
                   reserved: false,
                   nud: [Function: itself],
                   led: null,
                   std: null,
                   lbp: 0,
                   scope: [Circular] },
                y: [Circular],
                z: 
                 { value: 'z',
                   arity: 'name',
                   reserved: false,
                   nud: [Function: itself],
                   led: null,
                   std: null,
                   lbp: 0,
                   scope: [Circular] },
                return: 
                 { value: 'return',
                   arity: 'statement',
                   reserved: true,
                   first: 
                    { value: '+',
                      arity: 'binary',
                      first: { value: 'x', arity: 'name' },
                      second: 
                       { value: '*',
                         arity: 'binary',
                         first: { value: 'y', arity: 'name' },
                         second: { value: 'z', arity: 'name' } } } } },
             parent: 
              { def: 
                 { var: { value: 'var', arity: 'name', reserved: true },
                   beans: 
                    { value: 'beans',
                      arity: 'name',
                      reserved: false,
                      nud: [Function: itself],
                      led: null,
                      std: null,
                      lbp: 0,
                      scope: [Circular] } },
                parent: undefined } } },
        { value: 'z',
          arity: 'name',
          reserved: false,
          nud: [Function: itself],
          led: null,
          std: null,
          lbp: 0,
          scope: 
           { def: 
              { cool: 
                 { value: 'cool',
                   arity: 'name',
                   reserved: false,
                   nud: [Function: itself],
                   led: null,
                   std: null,
                   lbp: 0,
                   scope: [Circular] },
                x: 
                 { value: 'x',
                   arity: 'name',
                   reserved: false,
                   nud: [Function: itself],
                   led: null,
                   std: null,
                   lbp: 0,
                   scope: [Circular] },
                y: 
                 { value: 'y',
                   arity: 'name',
                   reserved: false,
                   nud: [Function: itself],
                   led: null,
                   std: null,
                   lbp: 0,
                   scope: [Circular] },
                z: [Circular],
                return: 
                 { value: 'return',
                   arity: 'statement',
                   reserved: true,
                   first: 
                    { value: '+',
                      arity: 'binary',
                      first: { value: 'x', arity: 'name' },
                      second: 
                       { value: '*',
                         arity: 'binary',
                         first: { value: 'y', arity: 'name' },
                         second: { value: 'z', arity: 'name' } } } } },
             parent: 
              { def: 
                 { var: { value: 'var', arity: 'name', reserved: true },
                   beans: 
                    { value: 'beans',
                      arity: 'name',
                      reserved: false,
                      nud: [Function: itself],
                      led: null,
                      std: null,
                      lbp: 0,
                      scope: [Circular] } },
                parent: undefined } } } ],
     second: 
      { value: 'return',
        arity: 'statement',
        reserved: true,
        first: 
         { value: '+',
           arity: 'binary',
           first: { value: 'x', arity: 'name' },
           second: 
            { value: '*',
              arity: 'binary',
              first: { value: 'y', arity: 'name' },
              second: { value: 'z', arity: 'name' } } } } } }


```



## References
[<span id="one">1</span>]  http://javascript.crockford.com/tdop/tdop.html
  Douglas Crockford's original TDOP parser. 

[2] http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing/ 
  This post by Eli Bendersky is a solid explanation of how TDOP works.

